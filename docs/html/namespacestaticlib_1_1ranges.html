<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_ranges: staticlib::ranges Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_ranges
   &#160;<span id="projectnumber">1.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestaticlib.html">staticlib</a></li><li class="navelem"><a class="el" href="namespacestaticlib_1_1ranges.html">ranges</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">staticlib::ranges Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestaticlib_1_1ranges_1_1detail__adapter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges_1_1detail__adapter.html">detail_adapter</a></td></tr>
<tr class="memitem:namespacestaticlib_1_1ranges_1_1detail__concat"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges_1_1detail__concat.html">detail_concat</a></td></tr>
<tr class="memitem:namespacestaticlib_1_1ranges_1_1detail__filter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges_1_1detail__filter.html">detail_filter</a></td></tr>
<tr class="memitem:namespacestaticlib_1_1ranges_1_1detail__refwrap"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges_1_1detail__refwrap.html">detail_refwrap</a></td></tr>
<tr class="memitem:namespacestaticlib_1_1ranges_1_1detail__transform"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges_1_1detail__transform.html">detail_transform</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy implementation of <code>SinglePassRange</code> for <code>concat</code> (or <code>chain</code>) operation, after the pass all accessed elements of source ranges will be moved from (will retain in "valid but unspecified" state).  <a href="classstaticlib_1_1ranges_1_1concatted__range.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1filtered__range.html">filtered_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy implementation of <code>SinglePassRange</code> for <code>filter</code> operation, after the pass all accessed elements of source range will be moved from (will retain in "valid but unspecified" state).  <a href="classstaticlib_1_1ranges_1_1filtered__range.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1range__adapter.html">range_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Range for move-only objects, implements all the boilerplate to support C++11 <code>for</code> loops.  <a href="classstaticlib_1_1ranges_1_1range__adapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">refwrapped_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy implementation of <code>SinglePassRange</code> for <code>std::ref</code> operation.  <a href="classstaticlib_1_1ranges_1_1refwrapped__range.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">refwrapped_const_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy implementation of <code>SinglePassRange</code> for <code>std::cref</code> operation.  <a href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstaticlib_1_1ranges_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <code>std::reference_wrapper</code>, negative case.  <a href="structstaticlib_1_1ranges_1_1is__reference__wrapper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstaticlib_1_1ranges_1_1is__reference__wrapper_3_01std_1_1reference__wrapper_3_01T_01_4_01_4.html">is_reference_wrapper&lt; std::reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <code>std::reference_wrapper</code>, positive case.  <a href="structstaticlib_1_1ranges_1_1is__reference__wrapper_3_01std_1_1reference__wrapper_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy implementation of <code>SinglePassRange</code> for <code>transform</code> operation, after the pass all accessed elements of source range will be moved from (will retain in "valid but unspecified" state).  <a href="classstaticlib_1_1ranges_1_1transformed__range.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61d434f9cbe506baff3eb6f4bc75396f"><td class="memTemplParams" colspan="2">template&lt;typename Range1 , typename Range2 , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range1&gt;::value&gt;::type, class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range2&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a61d434f9cbe506baff3eb6f4bc75396f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a>&lt; Range1, Range2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a61d434f9cbe506baff3eb6f4bc75396f">concat</a> (Range1 &amp;&amp;range1, Range2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a61d434f9cbe506baff3eb6f4bc75396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily concatenates two input ranges into single output range.  <a href="#a61d434f9cbe506baff3eb6f4bc75396f"></a><br/></td></tr>
<tr class="memitem:af90b1ff2f6757a1483e0917fdd628ec9"><td class="memTemplParams" colspan="2">template&lt;typename Range1 , typename Range2 , class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range1::value_type&gt;::value&gt;::type, class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range2::value_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af90b1ff2f6757a1483e0917fdd628ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a>&lt; Range1, Range2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#af90b1ff2f6757a1483e0917fdd628ec9">concat</a> (Range1 &amp;range1, Range2 &amp;range2)</td></tr>
<tr class="memdesc:af90b1ff2f6757a1483e0917fdd628ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily concatenates two input ranges into single output range.  <a href="#af90b1ff2f6757a1483e0917fdd628ec9"></a><br/></td></tr>
<tr class="memitem:afd593a6c2c6b8a7c99b323eeed8d89ec"><td class="memTemplParams" colspan="2">template&lt;typename Range1 , typename Range2 &gt; </td></tr>
<tr class="memitem:afd593a6c2c6b8a7c99b323eeed8d89ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a><br class="typebreak"/>
&lt; <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a><br class="typebreak"/>
&lt; Range1 &gt;<br class="typebreak"/>
, <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a><br class="typebreak"/>
&lt; Range2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#afd593a6c2c6b8a7c99b323eeed8d89ec">concat</a> (const Range1 &amp;range1, const Range2 &amp;range2)</td></tr>
<tr class="memdesc:afd593a6c2c6b8a7c99b323eeed8d89ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily concatenates two input ranges into single output range taking elements by reference.  <a href="#afd593a6c2c6b8a7c99b323eeed8d89ec"></a><br/></td></tr>
<tr class="memitem:aaf54ab5ff4b924f39e0d00b3a23695d3"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Pred , typename Dest , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aaf54ab5ff4b924f39e0d00b3a23695d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1filtered__range.html">filtered_range</a>&lt; Range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a>, Dest &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#aaf54ab5ff4b924f39e0d00b3a23695d3">filter</a> (Range &amp;&amp;source_range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a> predicate, Dest offcast_dest)</td></tr>
<tr class="memdesc:aaf54ab5ff4b924f39e0d00b3a23695d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily filters input range into output range checking each element using specified <code>Predicate</code>.  <a href="#aaf54ab5ff4b924f39e0d00b3a23695d3"></a><br/></td></tr>
<tr class="memitem:a08fc1e68e11d00d969f584bc9baaf1be"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Pred , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a08fc1e68e11d00d969f584bc9baaf1be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a08fc1e68e11d00d969f584bc9baaf1be">filter</a> (Range &amp;&amp;source_range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a> predicate)-&gt; <a class="el" href="classstaticlib_1_1ranges_1_1filtered__range.html">filtered_range</a>&lt; Range</td></tr>
<tr class="memdesc:a08fc1e68e11d00d969f584bc9baaf1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily filters input range into output range checking each element using specified <code>Predicate</code>.  <a href="#a08fc1e68e11d00d969f584bc9baaf1be"></a><br/></td></tr>
<tr class="memitem:a27a19236f81e2600986c328af932e94e"><td class="memTemplParams" colspan="2">template&lt;typename Range , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a27a19236f81e2600986c328af932e94e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a27a19236f81e2600986c328af932e94e">emplace_to_vector</a> (Range &amp;&amp;range)-&gt; std</td></tr>
<tr class="memdesc:a27a19236f81e2600986c328af932e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all the elements from the specified range into vector using <code>emplace_back</code>  <a href="#a27a19236f81e2600986c328af932e94e"></a><br/></td></tr>
<tr class="memitem:ab52122c4e40e8fcd02d3432d847315b1"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Range , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab52122c4e40e8fcd02d3432d847315b1"><td class="memTemplItemLeft" align="right" valign="top">Dest &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#ab52122c4e40e8fcd02d3432d847315b1">emplace_to</a> (Dest &amp;dest, Range &amp;&amp;range)</td></tr>
<tr class="memdesc:ab52122c4e40e8fcd02d3432d847315b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all the elements from the specified range into specified destination using <code>emplace_back</code>.  <a href="#ab52122c4e40e8fcd02d3432d847315b1"></a><br/></td></tr>
<tr class="memitem:a74be3b78fbce7f7c9e2c65692f5af579"><td class="memTemplParams" colspan="2">template&lt;typename Elem &gt; </td></tr>
<tr class="memitem:a74be3b78fbce7f7c9e2c65692f5af579"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a74be3b78fbce7f7c9e2c65692f5af579">ignore_offcast</a> (Elem el)</td></tr>
<tr class="memdesc:a74be3b78fbce7f7c9e2c65692f5af579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use as an offcast <code>FunctionObject</code> argument for <code>filter</code> function.  <a href="#a74be3b78fbce7f7c9e2c65692f5af579"></a><br/></td></tr>
<tr class="memitem:a146deb5a26b1a48da4c709afe6cad962"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Elem  = typename Dest::value_type&gt; </td></tr>
<tr class="memitem:a146deb5a26b1a48da4c709afe6cad962"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(Elem)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a146deb5a26b1a48da4c709afe6cad962">offcast_into</a> (Dest &amp;dest)</td></tr>
<tr class="memdesc:a146deb5a26b1a48da4c709afe6cad962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use as an offcast <code>FunctionObject</code> argument for <code>filter</code> function.  <a href="#a146deb5a26b1a48da4c709afe6cad962"></a><br/></td></tr>
<tr class="memitem:af3c7c7be3b948f790e6d0989f008f224"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Pred &gt; </td></tr>
<tr class="memitem:af3c7c7be3b948f790e6d0989f008f224"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#af3c7c7be3b948f790e6d0989f008f224">any</a> (Range &amp;range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a> predicate)</td></tr>
<tr class="memdesc:af3c7c7be3b948f790e6d0989f008f224"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>any</code> algorithm implementation for the arbitrary ranges  <a href="#af3c7c7be3b948f790e6d0989f008f224"></a><br/></td></tr>
<tr class="memitem:a425403bc10993c2a75e701749220b45b"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Pred , typename Elem &gt; </td></tr>
<tr class="memitem:a425403bc10993c2a75e701749220b45b"><td class="memTemplItemLeft" align="right" valign="top">Elem&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a425403bc10993c2a75e701749220b45b">find</a> (Range &amp;range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a> predicate, Elem not_found_el)</td></tr>
<tr class="memdesc:a425403bc10993c2a75e701749220b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>find</code> algorithm implementation for the arbitrary ranges, found element will be <code>move-returned</code> to the caller  <a href="#a425403bc10993c2a75e701749220b45b"></a><br/></td></tr>
<tr class="memitem:a2afe4c909819c195c772f8d1cdcc7897"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a2afe4c909819c195c772f8d1cdcc7897"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">refwrapped_range</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a2afe4c909819c195c772f8d1cdcc7897">refwrap</a> (Range &amp;range)</td></tr>
<tr class="memdesc:a2afe4c909819c195c772f8d1cdcc7897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily copies input range into output range using <code>std::ref</code> function on each element.  <a href="#a2afe4c909819c195c772f8d1cdcc7897"></a><br/></td></tr>
<tr class="memitem:a1de841b89e97902abec905fa4268e4ec"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a1de841b89e97902abec905fa4268e4ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">refwrapped_const_range</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a1de841b89e97902abec905fa4268e4ec">refwrap</a> (const Range &amp;range)</td></tr>
<tr class="memdesc:a1de841b89e97902abec905fa4268e4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily copies input range into output range using <code>std::cref</code> function on each element.  <a href="#a1de841b89e97902abec905fa4268e4ec"></a><br/></td></tr>
<tr class="memitem:aa360fee5a9ddbee8293606fa8fda9a00"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Func , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa360fee5a9ddbee8293606fa8fda9a00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a>&lt; Range, Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#aa360fee5a9ddbee8293606fa8fda9a00">transform</a> (Range &amp;&amp;range, Func functor)</td></tr>
<tr class="memdesc:aa360fee5a9ddbee8293606fa8fda9a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily transforms input range into output range applying functor to each element.  <a href="#aa360fee5a9ddbee8293606fa8fda9a00"></a><br/></td></tr>
<tr class="memitem:a4a268443fee3933e13ac0193c181c59c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Func , class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range::value_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4a268443fee3933e13ac0193c181c59c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a>&lt; Range, Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a4a268443fee3933e13ac0193c181c59c">transform</a> (Range &amp;range, Func functor)</td></tr>
<tr class="memdesc:a4a268443fee3933e13ac0193c181c59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily transforms input range into output range applying functor to each element.  <a href="#a4a268443fee3933e13ac0193c181c59c"></a><br/></td></tr>
<tr class="memitem:a6773f95e821e87edcd046b5f14b0addb"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Func &gt; </td></tr>
<tr class="memitem:a6773f95e821e87edcd046b5f14b0addb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a><br class="typebreak"/>
&lt; <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a><br class="typebreak"/>
&lt; Range &gt;, Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a6773f95e821e87edcd046b5f14b0addb">transform</a> (const Range &amp;range, Func functor)</td></tr>
<tr class="memdesc:a6773f95e821e87edcd046b5f14b0addb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily transforms input range into output range applying functor to each element taking it by reference.  <a href="#a6773f95e821e87edcd046b5f14b0addb"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8298af94824ce650f372db31da63e0ea"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a></td></tr>
</table>
<h2>Function Documentation</h2>
<a class="anchor" id="af3c7c7be3b948f790e6d0989f008f224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::ranges::any </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>any</code> algorithm implementation for the arbitrary ranges </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>input range </td></tr>
    <tr><td class="paramname">predicate</td><td>function to check range elements with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function returned true on some range element, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a61d434f9cbe506baff3eb6f4bc75396f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1 , typename Range2 , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range1&gt;::value&gt;::type, class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range2&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a>&lt;Range1, Range2&gt; staticlib::ranges::concat </td>
          <td>(</td>
          <td class="paramtype">Range1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily concatenates two input ranges into single output range. </p>
<p>Elements are moved from source ranges one by one, All accessed elements of source ranges will be left in "valid but unspecified state". Created range wrapper will own specified ranges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range1</td><td>first source range </td></tr>
    <tr><td class="paramname">source_range2</td><td>second source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated range </dd></dl>

</div>
</div>
<a class="anchor" id="af90b1ff2f6757a1483e0917fdd628ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1 , typename Range2 , class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range1::value_type&gt;::value&gt;::type, class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range2::value_type&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a>&lt; <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">staticlib::ranges::refwrapped_range</a>&lt; Range1 &gt;, <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">staticlib::ranges::refwrapped_range</a>&lt; Range2 &gt; &gt; staticlib::ranges::concat </td>
          <td>(</td>
          <td class="paramtype">Range1 &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range2 &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily concatenates two input ranges into single output range. </p>
<p>Lazily concatenates two input ranges into single output range taking elements by reference.</p>
<p>Elements are moved from source ranges one by one, All accessed elements of source ranges will be left in "valid but unspecified state". Created range wrapper will own specified ranges. This overload is a "special-case" that will accept only (expectedly "temporary") input ranges which contain <code>std::reference_wrapper</code> elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range1</td><td>first source range </td></tr>
    <tr><td class="paramname">source_range2</td><td>second source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated range</dd></dl>
<p>Created range wrapper will NOT own specified ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range1</td><td>first source range </td></tr>
    <tr><td class="paramname">source_range2</td><td>second source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated range </dd></dl>

</div>
</div>
<a class="anchor" id="afd593a6c2c6b8a7c99b323eeed8d89ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1 , typename Range2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1concatted__range.html">concatted_range</a>&lt;<a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a>&lt;Range1&gt;, <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a>&lt;Range2&gt; &gt; staticlib::ranges::concat </td>
          <td>(</td>
          <td class="paramtype">const Range1 &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2 &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily concatenates two input ranges into single output range taking elements by reference. </p>
<p>Created range wrapper will NOT own specified ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range1</td><td>first source range </td></tr>
    <tr><td class="paramname">source_range2</td><td>second source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated range </dd></dl>

</div>
</div>
<a class="anchor" id="ab52122c4e40e8fcd02d3432d847315b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Range , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Dest&amp; staticlib::ranges::emplace_to </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves all the elements from the specified range into specified destination using <code>emplace_back</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination container </td></tr>
    <tr><td class="paramname">range</td><td>source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination container </dd></dl>

</div>
</div>
<a class="anchor" id="a27a19236f81e2600986c328af932e94e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto staticlib::ranges::emplace_to_vector </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves all the elements from the specified range into vector using <code>emplace_back</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range with <code>MoveConstructible</code> elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing all element from specified range </dd></dl>

</div>
</div>
<a class="anchor" id="aaf54ab5ff4b924f39e0d00b3a23695d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Pred , typename Dest , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1filtered__range.html">filtered_range</a>&lt;Range, <a class="el" href="namespacestaticlib_1_1ranges.html#a8298af94824ce650f372db31da63e0ea">Pred</a>, Dest&gt; staticlib::ranges::filter </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>source_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dest&#160;</td>
          <td class="paramname"><em>offcast_dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily filters input range into output range checking each element using specified <code>Predicate</code>. </p>
<p>Elements are moved from source range one by one, All accessed elements of source range will be left in "valid but unspecified state". Elements that won't match the <code>Predicate</code> will be applied to specified <code>FunctionObject</code>. Created range wrapper will own specified ranges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range</td><td>reference to source range </td></tr>
    <tr><td class="paramname">predicate</td><td><code>Predicate</code> to check source element against it </td></tr>
    <tr><td class="paramname">offcast_dest</td><td><code>FunctionObject</code> to apply offcast elements to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered range </dd></dl>

</div>
</div>
<a class="anchor" id="a08fc1e68e11d00d969f584bc9baaf1be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Pred , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto staticlib::ranges::filter </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>source_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily filters input range into output range checking each element using specified <code>Predicate</code>. </p>
<p>Elements are moved from source range one by one, All accessed elements of source range will be left in "valid but unspecified state". Created range wrapper will own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_range</td><td>reference to source range </td></tr>
    <tr><td class="paramname">predicate</td><td><code>Predicate</code> to check source element against it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered range </dd></dl>

</div>
</div>
<a class="anchor" id="a425403bc10993c2a75e701749220b45b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Pred , typename Elem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Elem staticlib::ranges::find </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Elem&#160;</td>
          <td class="paramname"><em>not_found_el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>find</code> algorithm implementation for the arbitrary ranges, found element will be <code>move-returned</code> to the caller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>input range </td></tr>
    <tr><td class="paramname">predicate</td><td>function to check range elements with </td></tr>
    <tr><td class="paramname">not_found_el</td><td>this element will be returned if predicate won't match any element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range element that will match the predicate, <code>not_found_el</code> argument if no elements will match </dd></dl>

</div>
</div>
<a class="anchor" id="a74be3b78fbce7f7c9e2c65692f5af579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::ranges::ignore_offcast </td>
          <td>(</td>
          <td class="paramtype">Elem&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to use as an offcast <code>FunctionObject</code> argument for <code>filter</code> function. </p>
<p>Discards all offcast elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>offcast object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a146deb5a26b1a48da4c709afe6cad962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Elem  = typename Dest::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Elem)&gt; staticlib::ranges::offcast_into </td>
          <td>(</td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to use as an offcast <code>FunctionObject</code> argument for <code>filter</code> function. </p>
<p>Emplaces all offcast elements into specified container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>container to emplace offcast elements into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>FunctionObject</code> argument for <code>filter</code> function </dd></dl>

</div>
</div>
<a class="anchor" id="a2afe4c909819c195c772f8d1cdcc7897"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">refwrapped_range</a>&lt;Range&gt; staticlib::ranges::refwrap </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily copies input range into output range using <code>std::ref</code> function on each element. </p>
<p>Created range wrapper will NOT own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cloned range </dd></dl>

</div>
</div>
<a class="anchor" id="a1de841b89e97902abec905fa4268e4ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">refwrapped_const_range</a>&lt;Range&gt; staticlib::ranges::refwrap </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily copies input range into output range using <code>std::cref</code> function on each element. </p>
<p>Created range wrapper will NOT own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cloned range </dd></dl>

</div>
</div>
<a class="anchor" id="aa360fee5a9ddbee8293606fa8fda9a00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Func , class  = typename std::enable_if&lt;!std::is_lvalue_reference&lt;Range&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a>&lt;Range, Func&gt; staticlib::ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily transforms input range into output range applying functor to each element. </p>
<p>Elements are moved from source range one by one, All accessed elements of source range will be left in "valid but unspecified state". Created range wrapper will own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
    <tr><td class="paramname">functor</td><td>transformation <code>FunctionObject</code>, can be move-only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed range </dd></dl>

</div>
</div>
<a class="anchor" id="a4a268443fee3933e13ac0193c181c59c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Func , class  = typename std::enable_if&lt;is_reference_wrapper&lt;typename Range::value_type&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a>&lt; <a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__range.html">staticlib::ranges::refwrapped_range</a>&lt; Range &gt;, Func &gt; staticlib::ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily transforms input range into output range applying functor to each element. </p>
<p>Lazily transforms input range into output range applying functor to each element taking it by reference.</p>
<p>Elements are moved from source range one by one, All accessed elements of source range will be left in "valid but unspecified state". Created range wrapper will own specified range. This overload is a "special-case" that will accept only (expectedly "temporary") input ranges which contain <code>std::reference_wrapper</code> elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
    <tr><td class="paramname">functor</td><td>transformation <code>FunctionObject</code>, can be move-only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed range</dd></dl>
<p>Created range wrapper will NOT own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
    <tr><td class="paramname">functor</td><td>transformation <code>FunctionObject</code>, can be move-only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed range </dd></dl>

</div>
</div>
<a class="anchor" id="a6773f95e821e87edcd046b5f14b0addb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1ranges_1_1transformed__range.html">transformed_range</a>&lt;<a class="el" href="classstaticlib_1_1ranges_1_1refwrapped__const__range.html">staticlib::ranges::refwrapped_const_range</a>&lt;Range&gt;, Func&gt; staticlib::ranges::transform </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazily transforms input range into output range applying functor to each element taking it by reference. </p>
<p>Created range wrapper will NOT own specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>source range </td></tr>
    <tr><td class="paramname">functor</td><td>transformation <code>FunctionObject</code>, can be move-only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed range </dd></dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="a8298af94824ce650f372db31da63e0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">staticlib::ranges::Pred</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 23 2017 16:35:15 for staticlib_ranges by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
